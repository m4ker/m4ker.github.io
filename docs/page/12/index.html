<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Maker&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Maker&#39;s Blog">
<meta property="og:url" content="https://blog.foolbird.net/page/12/index.html">
<meta property="og:site_name" content="Maker&#39;s Blog">
<meta property="og:locale">
<meta property="article:author" content="王默">
<meta name="twitter:card" content="summary">
<meta name="twitter:creator" content="@m4ker">
  
    <link rel="alternative" href="/atom.xml" title="Maker&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <!--
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  -->
  
<link rel="stylesheet" href="/css/style.css">

  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Maker&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">我相信, 太阳地下有很多值得去的地方, 最近的就在我们心中.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/history">History</a>
        
        
          <a class="main-nav-link" href="/atom.xml" title="RSS Feed">RSS</a>
        
      </nav>
      <nav id="sub-nav">
      </nav>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-1774" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/1774.html">Magento安装教程</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/1774.html" class="article-date">
  <time datetime="2011-10-22T07:03:18.000Z" itemprop="datePublished">2011-10-22</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>1.下载</strong></p>
<p>从官方网站(<a href="http://www.magentocommerce.com/download">http://www.magentocommerce.com/download</a>)下载最新版本的magento及示例数据。</p>
<ul>
<li>系统程序Full Release - stable version ver 1.6.1.0 - Added October 19, 2011</li>
<li>示例数据Sample Data ver 1.2.0 - Added December 29, 2008<br><strong>2.安装</strong></li>
</ul>
<p>在安装之前，确认你已经安装了php运行环境，并确保apache和mysql服务已经正常运行。将解压后的目录放到web目录下，如果要安装测试数据需要把Sample Data中的media目录复制到magento安装目录中去。</p>
<ul>
<li>xampp的web目录是htdocs</li>
<li>WAMPServer的web目录是Apache\WWW</li>
</ul>
<p><a href="/1774.html/magento-install-1"><img src="/wp-content/uploads/2011/10/magento-install-1.png" title="magento-install-1"></a></p>
<p>打开<a href="http://localhost/magento">http://localhost/magento</a> 开始按照提示进行安装。</p>
<p><a href="/1774.html/magento-install-2"><img src="/wp-content/uploads/2011/10/magento-install-2-500x272.png" title="magento-install-2"></a></p>
<p>选择同意条款，下一步</p>
<p><a href="/1774.html/magento-install-3"><img src="/wp-content/uploads/2011/10/magento-install-3-500x249.png" title="magento-install-3"></a></p>
<p>选择时区和货币种类，下一步</p>
<p><a href="/1774.html/magento-install-4"><img src="/wp-content/uploads/2011/10/magento-install-4-500x83.png" title="magento-install-4"></a></p>
<p>如果未做相应设置可能会出现上面这种提示，因为magento是基于这些模块运行的。</p>
<p>到你的php.ini中找到这个下面这些内容:</p>
<p><code>extension=php_mcrypt.dll extension=php_curl.dll extension=php_mysql.dll extension=php_mysqli.dll extension=php_pdo_mysql.dll</code></p>
<p>确保前面的分号”;”已经被去掉</p>
<p>如果是xampp或者WAMPServer需要修改两个php.ini，xampp的在 apache\bin, WAMPServer在C:\wamp\bin\apache\Apache2.2.11\bin目录下， 在php.ini中做同样修改。</p>
<p>另外安装过程中创建数据库的时间比较长，需要临时修改PHP.ini中的一些设置：</p>
<p><code>max_input_time = 300 memory_limit = 512M mysql.connect_timeout = 300 max_execution_time = 1800</code></p>
<p>修改好之后重新启动apache服务,然后刷新页面之后弹出界面如下：</p>
<p><a href="/1774.html/magento-install-5"><img src="/wp-content/uploads/2011/10/magento-install-5-500x393.png" title="magento-install-5"></a></p>
<p>输入数据库名和数据库的用户名和密码，如果还没有数据库需要为magento手动创建一个新的数据库，WEB设置可以保持默认设置。</p>
<p><a href="/1774.html/magento-install-6"><img src="/wp-content/uploads/2011/10/magento-install-6-500x165.png" title="magento-install-6"></a></p>
<p>创建你的数据库 例如：</p>
<p>名称: magento<br>字符集为： utf-8<br>字符集设置： utf8_bin</p>
<p>如果需要使用测试数据，需要在下一步之前导入sample data。选择新创建的数据库，在右边的窗口中选择导入(Import)功能，选择sample data压缩包中的数据文件magento_sample_data_for_1.2.0.sql</p>
<p><a href="/1774.html/magento-install-7"><img src="/wp-content/uploads/2011/10/magento-install-7-500x393.png" title="magento-install-7"></a></p>
<p>在弹出窗口中找到下载并解压缩的示例数据文件后，点击open后返回导入页面，点击右下角的GO开始导入数据。</p>
<p>导入数据后，再通过浏览器窗口进行magento系统的安装。</p>
<p><a href="/1774.html/magento-install-8"><img src="/wp-content/uploads/2011/10/magento-install-8-500x337.png" title="magento-install-8"></a></p>
<p>可以选择会话(session)数据保存在数据库(database)中，默认是在临时文件夹中以文件的形式存在</p>
<p><a href="/1774.html/magento-install-9"><img src="/wp-content/uploads/2011/10/magento-install-9-500x271.png" title="magento-install-9"></a></p>
<p>填写你登陆后台的密码和账号，继续下一步</p>
<p><a href="/1774.html/magento-install-10"><img src="/wp-content/uploads/2011/10/magento-install-10.png" title="magento-install-10"></a></p>
<p>到这里magento就已经安装完毕了，点击Go to Backend或者进入<a href="http://localhost/magento/index.php/admin/%E7%99%BB%E9%99%86%E4%BD%A0%E7%9A%84%E5%90%8E%E5%8F%B0%E3%80%82">http://localhost/magento/index.php/admin/登陆你的后台。</a></p>
<p><a href="/1774.html/magento-install-11"><img src="/wp-content/uploads/2011/10/magento-install-11-500x171.png" title="magento-install-11"></a></p>
<p><a href="/1774.html/magento-install-12"><img src="/wp-content/uploads/2011/10/magento-install-12-500x189.png" title="magento-install-12"></a></p>
<p>如果安装了示例数据，再安装电子商务系统后，当访问具体商品时会出错，提示访问的页面不存在。这是因为系统生成的静态网址需要被更新，因此我们需要重新建立静态网址索引，登陆系统管理后台，进行system&#x2F;index management页面，选择所有的索引（最重要的就是catalog url rewrites），然后选择重建索引（Reindex data）并执行。</p>
<p><a href="/1774.html/magento-install-14"><img src="/wp-content/uploads/2011/10/magento-install-14-500x129.png" title="magento-install-14"></a></p>
<p>重建索引后再访问具体商品时就能正常访问了。</p>
<p><strong>3.汉化</strong></p>
<p>在Magento 1.6版本中的后台默认已经支持中文，对前台需要我们手工进行汉化。</p>
<p>方法一,通过Magento  Connect自动安装程序安装</p>
<p>在管理界面上选择Magento connect Manager进入插件安装管理界面</p>
<p><a href="/1774.html/magento-install-15"><img src="/wp-content/uploads/2011/10/magento-install-15-500x192.png" title="magento-install-15"></a></p>
<p>在<a href="http://www.magentocommerce.com网站上查找相关的插件：">www.magentocommerce.com网站上查找相关的插件：</a></p>
<p><a href="http://www.magentocommerce.com/extension/359/magento-community-modules--chinese-simplified-china-language-pack">http://www.magentocommerce.com/extension/359/magento-community-modules--chinese-simplified-china-language-pack</a></p>
<p>Magento Community Modules - Chinese Simplified (China) Language Pack</p>
<p>KEY: magento-community&#x2F;Locale_Mage_community_zh_CN</p>
<p>由于这个插件还处于beta版本，我们要先设置插件管理可以接受beta版本的程序（默认只接受稳定版本的插件）。</p>
<p>在setting页面上选择可以接受状态为Beta,然后点击保存设置</p>
<p><a href="/1774.html/magento-install-16"><img src="/wp-content/uploads/2011/10/magento-install-16-500x278.png" title="magento-install-16"></a></p>
<p>把这个KEY拷贝粘贴到插件管理界面上的插件代码文件框中，然后点击安装即可。</p>
<p><a href="/1774.html/magento-install-17"><img src="/wp-content/uploads/2011/10/magento-install-17-500x157.png" title="magento-install-17"></a></p>
<p>方法二,把汉化文件包拷贝到相关的目录下</p>
<p>把汉化包解压得到一个文件夹app，拷贝这个文件夹到安装目录下，覆盖其中的app文件夹即可。</p>
<p><em>注：本文为修改版，原文出自豆丁网。</em> </p>

        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.foolbird.net/1774.html" data-id="cm4fsa2ce001mplv480c77vso" class="article-share-link">Share</a>
      
        <a href="https://blog.foolbird.net/1774.html#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/magento/" rel="tag">magento</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%89%E8%A3%85/" rel="tag">安装</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%99%E7%A8%8B/" rel="tag">教程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-1760" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/1760.html">深入理解Magento – 第七章 – 自定义Magento系统配置</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/1760.html" class="article-date">
  <time datetime="2011-10-22T06:22:05.000Z" itemprop="datePublished">2011-10-22</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%98%E6%A1%A3/">存档</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="深入理解Magento"><a href="#深入理解Magento" class="headerlink" title="深入理解Magento"></a>深入理解Magento</h1><p>作者：<a href="http://alanstorm.com/">Alan Storm</a><br>翻译：<a href="http://www.zhlmmc.com/">Hailong Zhang</a></p>
<h3 id="第七章-–-自定义Magento系统配置"><a href="#第七章-–-自定义Magento系统配置" class="headerlink" title="第七章 – 自定义Magento系统配置"></a>第七章 – 自定义Magento系统配置</h3><p>Magento拥有十分强大的后台管理系统。作为一名开发人员，这套后台管理系统可以让你的用户简单直接的配置Magento系统或者你创建的模 块。和Magento的其他功能一样，你第一次使用这套管理系统的时候可能觉得很麻烦，但是一旦你上手了，你会发现它强大的功能是那么吸引人。那么让我们 开始吧。我们这一章的例子依然是基于Helloworld模块。</p>
<h4 id="添加系统配置文件"><a href="#添加系统配置文件" class="headerlink" title="添加系统配置文件"></a>添加系统配置文件</h4><p>首先我们要为模块添加一个系统配置文件。这个文件和“config.xml”是不搭界的<br>app&#x2F;code&#x2F;local&#x2F;Zhlmmc&#x2F;Helloworld&#x2F;etc&#x2F;system.xml<br>和全局配置（global config）相似，系统配置也是单独存储的。我们可以通过下面这段代码来获取系统配置文件<br>&#x2F;&#x2F;header(&#039;Content-Type: text&#x2F;xml&#039;);<br>header(&#039;Content-Type: text&#x2F;plain&#039;);<br>echo $config &#x3D; Mage::getConfig()<br>-&gt;loadModulesConfiguration(&#039;system.xml&#039;)<br>-&gt;getNode()<br>-&gt;asXML();<br>exit;<br>你可以把这段代码放到任何执行函数（Action  Method）中。“loadModulesConfiguration”方法会搜索所有配置好的模块的“etc”文件夹，寻找以传入的参数为名字的文 件，在这个例子中是“system.xml”。Magento有很多不同的配置文件，比如api.xml， wsdl.xml， wsdl2.xml，  convert.xml， compilation.xml， install.xml。你可以为你创建的模块创建这些配置文件。</p>
<h4 id="添加一个标签页"><a href="#添加一个标签页" class="headerlink" title="添加一个标签页"></a>添加一个标签页</h4><p>我们首先在后台系统管理页面添加一个标签页（Tab）。标签页就是后台“System-&gt;Configuration”页面左侧的导航栏。默 认的标签页有General，Catalog，Customers，Sales，Services等等。我们来创建一个新的标签页叫做“Hello  Config”。创建如下文件<br>Location: app&#x2F;code&#x2F;local&#x2F;Zhlmmc&#x2F;Helloworld&#x2F;etc&#x2F;system.xml<br><config><br><tabs><br><helloconfig translate="label" module="helloworld"><br><label>Hello Config</label><br><sort_order>99999</sort_order><br></helloconfig><br></tabs><br></config><br>我们来解释一下各个节点（Tag）的意思。【译者注：由于Tab和Tag中文翻译都是标签，所以这里我把Tag翻译成节点，以免混淆】 “<helloconfig>”就是我们要添加的标签页的定义节点，“helloconfig”是节点的ID。你可以任意命名这个ID，但是 必须全局唯一，也就是不能和别人用同样的ID。这个ID是用来唯一标示你的标签页的。“module&#x3D;helloworld”，意思是这个标签页属于哪个 模块。“<label>”节点的内容是标签的名字，也就是要显示在界面上的名字。“<sort_order>”指明了这个标签页 显示的位置。</p>
<p>打开后台“System-&gt;Configuration”，你会看到如下错误<br>Fatal error: Class &#039;Mage_Helloworld_Helper_Data&#039; not found in….</p>
<h4 id="Magento-Helper简介"><a href="#Magento-Helper简介" class="headerlink" title="Magento Helper简介"></a>Magento Helper简介</h4><p>正如许多其他的PHP MVC系统一样，Magento也有帮助类（Helper  Classes）。这些类用来提供一些不适合放在模型，视图或者控制器中的功能。Magento的帮助类也是采用分组类名的机制。也就是说我们可以覆盖默 认的帮助类，同时我们需要在config.xml中指定帮助类的基类名。</p>
<p>Magento系统默认模块有一个默认的帮助类。正如我们上面的异常显示，我们的Helloworld模块并没有指定一个默认的帮助类。下面让我们来添加一个。修改config.xml<br>File: app&#x2F;code&#x2F;local&#x2F;Zhlmmc&#x2F;Helloworld&#x2F;etc&#x2F;config.xml<br>&lt;!– … –&gt;<br><global><br>&lt;!– … –&gt;<br><helpers><br><helloworld><br><class>Zhlmmc_Helloworld_Helper</class><br></helloworld><br></helpers><br>&lt;!– … –&gt;<br></global><br>&lt;!– … –&gt;<br>你现在应该对这类配置相当熟悉了。“<helloworld>”节点就是模块的名字，“<class>”就是帮助类的基类名，命名方式如下<br>Packagename_Modulename_Helper<br>帮助类是通过全局对象Mage的静态方法“helper”来装载的。<br>Mage::helper(&#039;helloworld&#x2F;foo&#039;)<br>根据我们的配置，上面这行代码将会装载以下类<br>app&#x2F;code&#x2F;local&#x2F;Zhlmmc&#x2F;Helper&#x2F;Foo.php<br>class Zhlmmc_Helloworld_Helper_Foo<br>我们上面说过Magento默认每个模块有一个帮助类“data”<br>Mage::helper(&#039;helloworld&#039;);<br>Mage::helper(&#039;helloworld&#x2F;data&#039;);<br>上面这两行代码是等价的，都会装载以下类<br>app&#x2F;code&#x2F;local&#x2F;Zhlmmc&#x2F;Helper&#x2F;Data.php<br>class Zhlmmc_Helloworld_Helper_Data<br>下面我们来创建我们的帮助类<br>File: app&#x2F;code&#x2F;local&#x2F;Zhlmmc&#x2F;Helper&#x2F;Data.php<br>class Zhlmmc_Helloworld_Helper_Data extends Mage_Core_Helper_Abstract<br>{<br>}<br>清空Magento缓存，重新装载页面，你会发现错误不见了，但是我们的标签页还是没有出来。如果你好奇帮助类究竟能干什么，建议你去看看“Mage_Core_Helper_Abstract”类。</p>
<h4 id="添加新的段"><a href="#添加新的段" class="headerlink" title="添加新的段"></a>添加新的段</h4><p>好了，帮助类的介绍到此结束。下面我们来看看为什么我们的标签页不显示出来。在Magento中，每一个标签页都包含很多段（section）。举 个例子，“Advanced”标签页默认包含“Admin, System, Advanced,  Developer”四个段。如果一个标签页不包含任何段，那么这个标签页不会被显示出来。下面我们在system.xml中添加 “<section>”节点<br>Location: app&#x2F;code&#x2F;local&#x2F;Zhlmmc&#x2F;Helloworld&#x2F;etc&#x2F;system.xml<br><config><br><tabs><br><helloconfig translate="label" module="helloworld"><br><label>Hello Config</label><br><sort_order>99999</sort_order><br></helloconfig><br></tabs><br><sections><br><helloworld_options translate="label" module="helloworld"><br><label>Hello World Config Options</label><br><tab>helloconfig</tab><br><frontend_type>text</frontend_type><br><sort_order>1000</sort_order><br><show_in_default>1</show_in_default><br><show_in_website>1</show_in_website><br><show_in_store>1</show_in_store><br></helloworld_options><br></sections><br></config><br>这里有些节点你应该很熟悉，就不多解释了，来讲讲以前没见过的。</p>
<h4 id="什么是？"><a href="#什么是？" class="headerlink" title="什么是？"></a>什么是<helloworld_options />？</h4><p>和前面的<hellowconfig>相似，这个节点是用来唯一标示你的段，“helloworld_options”就是段的ID，可以随意取名，只要不重复就好。</p>
<h4 id="什么是？-1"><a href="#什么是？-1" class="headerlink" title="什么是？"></a>什么是<frontend_type />？</h4><p>这个节点有点搞。“<frontend_type />”在配置文件的其他部分有用（稍后会讲），放在这里其实没什么作用。但是核心模块在此处的配置文件都包含这个节点，所以我们也把它添加进去。</p>
<h4 id="什么是，-show-in-website-，？"><a href="#什么是，-show-in-website-，？" class="headerlink" title="什么是，&lt; show_in_website &#x2F;&gt;，？"></a>什么是<show_in_default />，&lt; show_in_website &#x2F;&gt;，<show_in_store />？</h4><p>这些节点的值是布尔类型的，0或者1。这些标签是用来控制在不同的环境下，当前段是否应该显示。</p>
<p>好了，我们已经配置好段了，清空缓存，再一次刷新页面，你应该看到“HELLO CONFIG”标签页显示出来了。</p>
<h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>如果你刚才点了我们创建的标签页下面的“Hello World Config  Options”，你大概会很失望。什么都没有显示出来，连左边的导航栏都没有了。这是因为“Adminhtml”在权限控制列表（Access  Control List,  ACL）中找不到我们创建的段的权限信息。【译者注：Adminhtml就是Magento的后台管理系统，属于Magento的一个核心模块】</p>
<p>ACL是一个很复杂的话题，但是我会介绍一些最基本的概念，以便于理解Magento的权限控制。这部分内容和上下文关系不大，如果你不感兴趣，可以直接跳到本节结尾，复制一段XML到你的config.xml就行了。</p>
<p>在Magento中，对于有些资源的访问时有限制的。用户必须先经过认证才能访问相关资源。在这里，资源（Resource）是一个广义的概念，它可能是 指一个页面，也可能是一个功能。Magento的系统配置功能（System Config）就是需要认证才能访问的资源。</p>
<p>任何一个资源都是通过一个URI来标识。比如说“web”配置段（属于后台管理General标签页）的URI是<br>admin&#x2F;system&#x2F;config&#x2F;web<br>我们“helloworld_options”段的URI是<br>admin&#x2F;system&#x2F;config&#x2F;helloworld_options<br>当一个用户访问一个受保护的资源的时候，后台管理系统（Adminhtml）的执行控制器会执行以下步骤</p>
<ol>
<li>为用户正在访问的资源生成一个URI</li>
<li>根据ACL系统检查该用户是否有权限访问指定的资源</li>
<li>如果用户拥有访问权限，那么进行用户指定的操作。否则，跳转到相应的错误页面（也可能是停止操作或者显示空白页面）。<br>如果你去“System -&gt; Permissions -&gt; Roles”页面，点击“Add New Role”按钮，你会看到所有系统的资源都以树形结构显示在页面上。</li>
</ol>
<h4 id="添加ACL权限"><a href="#添加ACL权限" class="headerlink" title="添加ACL权限"></a>添加ACL权限</h4><p>刚才说ACL中没有我们配置段的信息，那么我们来创建一个。请注意，如果你是创建一个新的段，那么你需要创建一个新的权限，如果你在已有的段上添加内容，你不需要创建权限。</p>
<p>在config.xml中，添加以下内容<br>File: app&#x2F;code&#x2F;local&#x2F;Zhlmmc&#x2F;Helloworld&#x2F;etc&#x2F;config.xml<br><config><br>&lt;!– … –&gt;<br><adminhtml><br><acl><br><resources><br><admin><br><children><br><system><br><children><br><config><br><children><br><helloworld_options></p>
<title>Store Hello World Module Section</title>
</helloworld_options>
</children>
</config>
</children>
</system>
</children>
</admin>
</resources>
</acl>
</adminhtml>
<!– … –>
</config>
让我们来分析一下这段代码。所有的资源定义都包含在如下代码中
<adminhtml>
<acl>
<resources>
</resource>
</acl>
</adminhtml>
在<resources>节点下面，每一个子节点都是URI的一部分，比如
<admin>
<children>
<system>
<children>
代表URI
admin/system
最后一个节点
<helloworld_options>
<title>Store Hello World Module Section</title>
</helloworld_options>
这里<title>的内容将会在后台权限管理的时候显示出来，也就是我们定义的权限的名字。

<p>清空Magento缓存，刷新页面，你应该能看到我们创建的配置段了，标准的后台管理页面，但是主体内容是空的，只有一个“Save  Config”按钮。你可能需要重新登录后台管理才能看到正确的页面。那是因为后台管理有一些额外的缓存。【译者注：我们添加了权限以后，管理员是默认拥 有该权限的，所以我们用管理员登录后台管理系统就能访问我们创建的段】</p>
<p>请注意，不懂事出于什么原因，Magento把<adminhtml />部分从全局配置中删掉了。所以，我们不能用之前创建的Configviewer来查看这部分内容。我正在研究Magento把<adminhtml />存在哪里了。</p>
<h4 id="添加组"><a href="#添加组" class="headerlink" title="添加组"></a>添加组</h4><p>【译者注：按照逻辑，这里应该讲的内容是添加选项。Mageto中，选项是按照组（Group）来划分的，所以我们在添加选项之前得先添加组。】修改system.xml<br>Location: app&#x2F;code&#x2F;local&#x2F;Zhlmmc&#x2F;Helloworld&#x2F;etc&#x2F;system.xml<br><config><br><tabs><br><helloconfig translate="label" module="helloworld"><br><label>Hello Config</label><br><sort_order>99999</sort_order><br></helloconfig><br></tabs><br><sections><br><helloworld_options translate="label" module="helloworld"><br><label>Hello World Config Options</label><br><tab>helloconfig</tab><br><frontend_type>text</frontend_type><br><sort_order>1000</sort_order><br><show_in_default>1</show_in_default><br><show_in_website>1</show_in_website><br><show_in_store>1</show_in_store><br><groups><br><messages translate="label"><br><label>Demo Of Config Fields</label><br><frontend_type>text</frontend_type><br><sort_order>1</sort_order><br><show_in_default>1</show_in_default><br><show_in_website>1</show_in_website><br><show_in_store>1</show_in_store><br></messages><br></groups><br></helloworld_options><br></sections><br></config><br>这里也没什么好解释的。刷新一下页面看看你就什么都明白了。</p>
<h4 id="添加配置选项"><a href="#添加配置选项" class="headerlink" title="添加配置选项"></a>添加配置选项</h4><p>最后，我们要添加每一个单独的配置选项。配置选项是以<fields />节点的形式添加到<messages />节点下面的。<br>&lt;!– … –&gt;<br><messages translate="label"><br><label>Demo Of Config Fields</label><br><frontend_type>text</frontend_type><br><sort_order>1</sort_order><br><show_in_default>1</show_in_default><br><show_in_website>1</show_in_website><br><show_in_store>1</show_in_store><br><fields><br><hello_message><br><label>Message</label><br><frontend_type>text</frontend_type><br><sort_order>1</sort_order><br><show_in_default>1</show_in_default><br><show_in_website>1</show_in_website><br><show_in_store>1</show_in_store><br></hello_message><br></fields><br></messages><br>&lt;!– … –&gt;<br>这里有一个节点需要说明，“<frontend_type>”，刚才说这个节点没什么用。但是这里有用了，这个节点说明了这个选项的数据类 型。你可以把它换成别的类型，比如“time”。这里支持大部分默认的Varien定义的数据类型（lib&#x2F;Varien&#x2F;Data&#x2F;Form &#x2F;Element）。这个有点像是工厂（Factory）设计模式。让我们把类型改成“select”。你会看到一个下拉框，但是没有选项。我们来添加选 项。首先我们要添加一个源模型（Source Model）<br><hello_message><br><label>Message</label><br><frontend_type>select</frontend_type><br>&lt;!– adding a source model –&gt;<br><source_model>helloworld&#x2F;words</source_model><br><sort_order>1</sort_order><br><show_in_default>1</show_in_default><br><show_in_website>1</show_in_website><br><show_in_store>1</show_in_store><br></hello_message><br>“<source_model>”定义了源模型的URI。和我们以前创建的模型一样，源模型也是一个模型，为“select”提供了默认的数据。我想我不说你也明白，根据这里的URI定义，我们要创建以下文件<br>File: app&#x2F;code&#x2F;local&#x2F;Zhlmmc&#x2F;Helloworld&#x2F;Model&#x2F;Words.php<br>class Zhlmmc_Helloworld_Model_Words<br>{<br>public function toOptionArray()<br>{<br>return array(<br>array(&#039;value&#039;&#x3D;&gt;1, &#039;label&#039;&#x3D;&gt;Mage::helper(&#039;helloworld&#039;)-&gt;<strong>(&#039;Hello&#039;)),<br>array(&#039;value&#039;&#x3D;&gt;2, &#039;label&#039;&#x3D;&gt;Mage::helper(&#039;helloworld&#039;)-&gt;</strong>(&#039;Goodbye&#039;)),<br>array(&#039;value&#039;&#x3D;&gt;3, &#039;label&#039;&#x3D;&gt;Mage::helper(&#039;helloworld&#039;)-&gt;<strong>(&#039;Yes&#039;)),<br>array(&#039;value&#039;&#x3D;&gt;4, &#039;label&#039;&#x3D;&gt;Mage::helper(&#039;helloworld&#039;)-&gt;</strong>(&#039;No&#039;)),<br>);<br>}<br>}<br>源模型提供了一个方法“toOptionsArray”，返回的数据时用来填充我们之前定义的配置选项的。这个方法在运行时会被“initFields”调用。“initFields”在以下类中定义<br>app&#x2F;code&#x2F;core&#x2F;Mage&#x2F;Adminhtml&#x2F;Block&#x2F;System&#x2F;Config&#x2F;Form.php<br>我们这里调用了帮助类的翻译函数（__）来获取数据。虽然不是很必要，但调用翻译函数总是一个好习惯。说不定哪天你要将模块翻译成日文呢。【译者注：值得 注意的是我们这里创建的模型不需要继承任何父类，只需要拥有“toOptionArray”方法就可以了。我觉得这个很不科学，起码要继承一个接口吧】</p>
<h4 id="在已有的配置段或者组中添加数据"><a href="#在已有的配置段或者组中添加数据" class="headerlink" title="在已有的配置段或者组中添加数据"></a>在已有的配置段或者组中添加数据</h4><p>除了新建一个标签页，或者配置段，你也可以利用已有的标签页和配置段，向里面添加内容。比如我们添加以下代码到system.xml<br>File: app&#x2F;code&#x2F;local&#x2F;Zhlmmc&#x2F;Helloworld&#x2F;etc&#x2F;system.xml<br><config><br>&lt;!– … –&gt;<br><sections><br>&lt;!– … –&gt;<br><general><br><groups><br><example><br><label>Example of Adding a Group</label><br><frontend_type>text</frontend_type><br><sort_order>1</sort_order><br><show_in_default>1</show_in_default><br><show_in_website>1</show_in_website><br><show_in_store>1</show_in_store><br></example><br></groups><br></general><br>&lt;!– … –&gt;</p>
</section>
</config>
刷新页面，你会在“General”标签页下面看到一个新的组，叫做“Example of Adding a Group”。

<h4 id="如何获得配置数据"><a href="#如何获得配置数据" class="headerlink" title="如何获得配置数据"></a>如何获得配置数据</h4><p>到目前为止，我们只是讲了如何设置Magento，可以让用户可以配置我们的模块。现在让我们来看看如何获取用户的配置数据。<br>Mage::getStoreConfig(&#039;helloworld_options&#x2F;messages&#x2F;hello_message&#039;);<br>上面这行代码就可以获取我们上面配置的那个“select”选项的数据。这个函数的参数是我们要获取的数据的URI，格式如下<br>section_name&#x2F;group_name&#x2F;field_name<br>你也可以通过以下代码来获取一个组或者段的所有值<br>Mage::getStoreConfig(&#039;helloworld_options&#x2F;messages&#039;);<br>Mage::getStoreConfig(&#039;helloworld_options&#039;);<br>最后，如果你想获取针对某个特定店面（store）的数据，你可以传入store ID<br>Mage::getStoreConfig(&#039;helloworld_options&#039;,1);</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这一章我们讲了如何在Magento的后台管理中添加个性化的配置。我们也顺便介绍了帮助类的使用和ACL基础。这里最重要的内容是后台配置的层级 结构，标签页包含了配置段，配置段包含了组，组包含了配置选项。我们将在以后的章节中介绍系统配置的高级内容，包括自定义格式，数据验证等等。</p>

        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.foolbird.net/1760.html" data-id="cm4fsa2ce001jplv4g05lbota" class="article-share-link">Share</a>
      
        <a href="https://blog.foolbird.net/1760.html#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-1758" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/1758.html">深入理解Magento – 第六章 – 高级Magento模型</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/1758.html" class="article-date">
  <time datetime="2011-10-22T06:20:40.000Z" itemprop="datePublished">2011-10-22</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%98%E6%A1%A3/">存档</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="深入理解Magento"><a href="#深入理解Magento" class="headerlink" title="深入理解Magento"></a>深入理解Magento</h1><p>作者：<a href="http://alanstorm.com/">Alan Storm</a><br>翻译：<a href="http://www.zhlmmc.com/">Hailong Zhang</a></p>
<h3 id="第六章-–-高级Magento模型"><a href="#第六章-–-高级Magento模型" class="headerlink" title="第六章 – 高级Magento模型"></a>第六章 – 高级Magento模型</h3><p>我们讲过Magento有两种模型，简单模型和EAV（Entity Attribute  Value）模型。上一章我们讲过所有的Magento模型都是继承自Mage_Core_Model_Abstract &#x2F;  Varien_Object。简单模型和EAV模型的区别在于资源模型（Model  Resource）。虽然所有的资源模型都最终继承“Mage_Core_Model_Resrouce_Abstract”，但是简单模型是直接继承 “Mage_Core_Model_Mysql4_Abstract”，而EAV模型是直接继承 “Mage_Eav_Model_Entity_Abstract”。</p>
<p>Magento这么做是由它的道理的。对于大部分开发人员或者用户来说，他们只需要知道一系列的方法能够操作模型，获得数据，数据到底是如何存储的并不是很重要。</p>
<h4 id="什么是EAV模型？"><a href="#什么是EAV模型？" class="headerlink" title="什么是EAV模型？"></a>什么是EAV模型？</h4><p>Wikipedia是这么定义的：<br><em>EAV（Entity-Attribute-Value）模型，也作Object-Attribute-Value模型或者开放模型是一种数据模型。这种数据模型常常用在一个对象的属性数目不是一定的情况下。在数学上，这种模型称为松散矩阵。</em></p>
<p>换一种方式理解，EAV模型就是数据表的一种泛化。在传统的数据库中，数据表的列的数量是一定的<br>+——————+<br>| products         |<br>+——————+<br>| product_id       |<br>| name             |<br>| price            |<br>| etc..            |<br>+——————+<br>+————+—————-+——————+———+<br>| product_id | name           | price            | etc…  |<br>+————+—————-+——————+———+<br>| 1          | Widget A       | 11.34            | etc…  |<br>+————+—————-+——————+———+<br>| 2          | Dongle B       | 6.34             | etc…  |<br>+————+—————-+——————+———+<br>在上面这张表中，每一个商品都有名称，价格等等。</p>
<p>在EAV模型中，每一个模型都有不同的属性。这对于电子商务的应用来说是很合适的。比如说一个网店可以卖笔记本，拥有CPU速度，颜色，内存等属性，但是 网店也可以卖衣服，有颜色属性，但是没有CPU速度。即使是卖衣服的网店，也有上衣和裤子之分，它们的属性也是不一样的。</p>
<p>有很多开源的或者商业的数据库是默认使用EAV模型的。但是一般的网站托管平台不提供这些数据库。所以Varien开发了一套基于PHP和MySQL的EAV系统。换句话说，它们在传统的关系型数据库上面开发了一套EAV数据库系统。</p>
<p>在使用的时候，EAV模型的属性是会分布在不同的MySQL数据表中。<br><a href="http://www.zhlmmc.com/wp-content/uploads/2010/04/eav.png"><img src="http://www.zhlmmc.com/wp-content/uploads/2010/04/eav.png" title="eav"></a><br>上面的这张图是Magento中关于“catalog_product”的表。每一个产品都是“catalog_product_entity”中的一 行。Magento系统中所有的属性（不仅仅是商品）都存放在“eav_attribute”表中，而属性的值都放在类似下面的表中 “catalog_product_entity_attribute_varchar”，  “catalog_product_entity_attribute_decimal”，  “catalog_product_entity_attribute_etc”。【译者注：如果你仔细观察上面这幅数据表结构图，你会发现明显少了一张 表，和“entity_type”有关。因为这里有“entity_type_id”出现，但却没有定义这个属性的表。这个表在Magneto中叫做 “eav_entity_type”。由于EAV模型中所有的模型数据都混在一套数据表中了，实体类型（entity_type）就是用来把不同的模型区 别开来的属性。假如我们要找出系统中所有的产品数据，那么Magento先通过“eav_entity_type”表获得产品模型的 “entity_type_id”，然后再通过上面这幅图的关系来拿到所有的数据。<br>】</p>
<p>在EAV系统下面，当你需要添加一个属性的时候，只需要在“eav_attribute”表中添加一行就行了。而传统的关系型数据库则需要修改数据表调用 “ALTER  TABLE”语句，复杂而且有风险。EAV模型的缺点是你不能通过一个简单的SQL语句就获得一个模型的所有属性。你往往需要调用多个SQL或者一个 SQL包干了多个join语句。</p>
<h4 id="实战EAV模型"><a href="#实战EAV模型" class="headerlink" title="实战EAV模型"></a>实战EAV模型</h4><p>我们已经介绍了EAV是怎么工作的了。下面我们要通过一个例子来说明要在Magento中创建一个EAV模型所需要的步骤。这部分内容大概是 Magento中最令人头疼的部分，95%的Magento用户都不会和这些代码打交道，但是理解EAV模型的原理能够帮助你更好的理解Magento的 代码和架构。</p>
<p>因为EAV模型的内容太多了，所以我假设你已经熟悉了前几章的内容，包括Magento MVC，组类名等等。在这一章我不会再重复这些内容。</p>
<h4 id="EAV形式的Hello-World"><a href="#EAV形式的Hello-World" class="headerlink" title="EAV形式的Hello World"></a>EAV形式的Hello World</h4><p>我们将为Hello World模块创建另外一个模型，使用EAV形式的资源模型。首先我们为模块创建一个新的模型叫做“Eavblogpost”。记住，简单模型和EAV模型的区别是资源模型，所以我们创建一个模型的基本步骤是一样的。<br><global><br>&lt;!– … –&gt;<br><models><br>&lt;!– … –&gt;<br><helloworld-eav><br><class>Zhlmmc_Helloworld_Model</class><br><resourceModel>helloworld-eav_mysql4</resourceModel><br></helloworld-eav><br>&lt;!– … –&gt;<br></models><br>&lt;!– … –&gt;<br></global><br>我想我不说你也应该知道，我们要创建一个新的模型文件。由于PHP  5.3和命名空间（namespaces）还没有被广泛采用，Magento中的类名仍然和文件的物理路径相关。这就导致了很多时候不知道一个URI所对 应的类究竟该放在什么文件夹下面。我发现我们可以利用Magento的异常信息来直接得到一个类的路径。比如，这里我们先不创建模型类，先来修改 BlogController来直接使用模型类，这样Magento就会报错说找不到模型类，并给出路径<br>public function eavReadAction(){<br>$eavModel &#x3D; Mage::getModel(&#039;helloworld-eav&#x2F;eavblogpost&#039;);<br>echo get_class($eavModel).”<br>“;<br>}<br>清空Magento缓存，访问以下URL<br><a href="http://127.0.0.1/Magento/helloworld/blog/eavRead">http://127.0.0.1/Magento/helloworld/blog/eavRead</a><br>跟预计的一样，你应该得到以下异常<br>Warning: include(Zhlmmc&#x2F;Helloworld&#x2F;Model&#x2F;Eavblogpost.php) [function.include]: failed to open stream: No such file or directory<br>所以我们应该创建如下文件<br>File: app&#x2F;code&#x2F;local&#x2F;Zhlmmc&#x2F;Helloworld&#x2F;Model&#x2F;Eavblogpost.php<br>class Zhlmmc_Helloworld_Model_Eavblogpost extends Mage_Core_Model_Abstract<br>{<br>protected function _construct()<br>{<br>$this-&gt;_init(&#039;helloworld-eav&#x2F;blogpost&#039;);<br>}<br>}<br>刷新页面，你应该看到下面的输出<br>Zhlmmc_Helloworld_Model_Eavblogpost<br>下面我们来创建资源模型。先定义资源模型<br><helloworld-eav_mysql4><br><class>Zhlmmc_Helloworld_Model_Resource_Eav_Mysql4</class><br><entities><br><blogpost></p>
<table>eavblog_posts</table>
</blogpost>
</entities>
</helloworld-eav_mysql4>
这里的标签名字和我们上面定义的模型的<resourceMode />是一致的。<entities />的定义和上一章是一样的。下面的适配器的定义
<resources>
<!– … ->
<helloworld-eav_write>
<connection>
<use>default_write</use>
</connection>
</helloworld-eav_write>
<helloworld-eav_read>
<connection>
<use>default_read</use>
</connection>
</helloworld-eav_read>
</resources>
然后再次利用Magento的异常，先修改“eavReadAction”
public function eavReadAction(){
$eavModel = Mage::getModel(&#039;helloworld-eav/eavblogpost&#039;);
$params = $this->getRequest()->getParams();
echo("Loading the blogpost with an ID of ".$params[&#039;id&#039;]."
");
$eavModel->load($params[&#039;id&#039;]);
$data = $eavModel->getData();
var_dump($data);
}
清空Magento缓存，访问URL
http://127.0.0.1/Magento/helloworld/blog/eavRead/id/1
你应该看到如下异常
Warning:  include(Zhlmmc/Helloworld/Model/Resource/Eav/Mysql4/Blogpost.php)  [function.include]: failed to open stream: No such file or directory
所以我们创建相应的资源模型类
File: app/code/local/Zhlmmc/Helloworld/Model/Resource/Eav/Mysql4/Blogpost.php
class Zhlmmc_Helloworld_Model_Resource_Eav_Mysql4_Blogpost extends Mage_Eav_Model_Entity_Abstract
{
public function _construct()
{
$resource = Mage::getSingleton(&#039;core/resource&#039;);
$this->setType(&#039;helloworld_eavblogpost&#039;);
$this->setConnection(
$resource->getConnection(&#039;helloworld-eav_read&#039;),
$resource->getConnection(&#039;helloworld-eav_write&#039;)
);
}
}
这个类和简单的资源模型就不一样。首先，我们这里继承的是“Mage_Eav_Model_Entity_Abstract”。其次，我们没有调用 “_init”方法。在EAV模型中我们需要自己来完成资源模型初始化的过程，包括，告诉资源模型使用哪个适配器，以及实体类型 （entity_type）。刷新URL，你应该看到如下异常
Invalid entity_type specified: helloworld_eavblogpost
根据我们上文所讲的内容，那这个异常的原因很明显，那就是“eav_entity_type”表中，没有需要的 “helloworld_eavblogpost”的数据。这里的“helloworld_eavblogpost”就是我们“setType”的参数。 让我们来看一下这张表长什么样
mysql> select * from eav_entity_type\G
*************************** 1\. row ***************************
entity_type_id: 1
entity_type_code: customer
entity_model: customer/customer
attribute_model:
entity_table: customer/entity
value_table_prefix:
entity_id_field:
is_data_sharing: 1
data_sharing_key: default
default_attribute_set_id: 1
increment_model: eav/entity_increment_numeric
increment_per_store: 0
increment_pad_length: 8
increment_pad_char: 0
additional_attribute_table: customer/eav_attribute
entity_attribute_collection: customer/attribute_collection
*************************** 2\. row ***************************
entity_type_id: 2
entity_type_code: customer_address
entity_model: customer/customer_address
attribute_model:
entity_table: customer/address_entity
value_table_prefix:
entity_id_field:
is_data_sharing: 1
data_sharing_key: default
default_attribute_set_id: 2
increment_model:
increment_per_store: 0
increment_pad_length: 8
increment_pad_char: 0
additional_attribute_table: customer/eav_attribute
entity_attribute_collection: customer/attribute_collection
正如我们前面讲过的，这张表包含了所有系统中的实体类型。我们的参数“helloworld_eavblogpost”就是实体类型的值，对应数据表列“entity_type_code”。

<h4 id="系统和应用程序"><a href="#系统和应用程序" class="headerlink" title="系统和应用程序"></a>系统和应用程序</h4><p>这一章讲的内容是Magento最重要的一个概念，也是很多人觉得头疼的概念。拿电脑来做比方。操作系统，比如Mac OS  X，Windows，Linux等等，是软件系统，而浏览器，比如FIrefox，Safari，IE等等是应用程序。Magento首先是一个系统，其 次才是一个应用程序。你可以在Magento系统之上创建一个电子商务应用。令人感到困惑的是Magento的代码在很多地方是以很原始的方式暴露给应用 程序的。EAV系统的配置和你网店的数据存放在统一数据库中就是一个例子。</p>
<p>随着你越来越深入Magento，你需要把Magento当作老式的 IBM 650 机器。也就是说，你必须对Magento有很深的了解才能对它运用自如。【译者注：这一段和上下文没什么关系，大概是作者有感而发】</p>
<h4 id="创建资源配置"><a href="#创建资源配置" class="headerlink" title="创建资源配置"></a>创建资源配置</h4><p>从理论上讲，你可以手动的在数据库中插入数据，让我们的EAV模型工作，但我还是不建议你这么做。所幸的是，Magento提供了一个特殊的资源配置类，包含了一些有用的方法能自动的创建一些数据，使得系统能工作。</p>
<p>我们先添加资源配置<br><resources><br>&lt;!– … –&gt;<br><helloworld-eav_setup><br><setup><br><module>Zhlmmc_Helloworld</module><br><class>Zhlmmc_Helloworld_Model_Entity_Setup</class><br></setup><br><connection><br><use>core_setup</use><br></connection><br></helloworld-eav_setup><br>&lt;!– … –&gt;<br></resources><br>创建资源配置类文件<br>File: app&#x2F;code&#x2F;local&#x2F;Zhlmmc&#x2F;Helloworld&#x2F;Model&#x2F;Entity&#x2F;Setup.php<br>class Zhlmmc_Helloworld_Model_Entity_Setup extends Mage_Eav_Model_Entity_Setup {<br>}<br>请注意，这里我们继承的父类是“Mage_Eav_Model_Entity_Setup”。最后，我们来创建安装脚本。如果你不熟悉这部分内容，请你参考前面章节的内容。<br>File: app&#x2F;code&#x2F;local&#x2F;Zhlmmc&#x2F;Helloworld&#x2F;sql&#x2F;helloworld-eav_setup&#x2F;mysql4-install-0.1.0.php<br><?php
$installer = $this;
throw new Exception("This is an exception to stop the installer from completing");
?><br>清空Magento缓存，访问任何页面，你应该看到以上异常。如果你没有看到异常，那说明你哪里配置错了。</p>
<p>请注意：我们将一步一步的创建安装脚本。如果你阅读了前面的章节，你应该知道我们必须删除“core_resource”数据表中的相应数据才能使得安装 脚本重新运行。所以在我们下面的例子中，当我们修改了安装脚本，我们都默认会删除“core_resource”表中的数据。正常使用Magento的时 候我们不需要这样做的，教程中的例子是极端情况。</p>
<h4 id="添加实体类型"><a href="#添加实体类型" class="headerlink" title="添加实体类型"></a>添加实体类型</h4><p>首先我们修改安装脚本如下<br>$installer &#x3D; $this;<br>$installer-&gt;addEntityType(&#039;helloworld_eavblogpost&#039;,Array(<br>&#x2F;&#x2F;entity_mode is the URL you&#039;d pass into a Mage::getModel() call<br>&#039;entity_model&#039;          &#x3D;&gt;&#039;helloworld-eav&#x2F;eavblogpost&#039;,<br>&#x2F;&#x2F;blank for now<br>&#039;attribute_model&#039;       &#x3D;&gt;&#039;&#039;,<br>&#x2F;&#x2F;table refers to the resource URI helloworld-eav&#x2F;blogpost<br>&#x2F;&#x2F;<helloworld-eav_mysql4>…<blogpost><table>eavblog_posts</table><br>&#039;table&#039;         &#x3D;&gt;&#039;helloworld-eav&#x2F;blogpost&#039;,<br>&#x2F;&#x2F;blank for now, but can also be eav&#x2F;entity_increment_numeric<br>&#039;increment_model&#039;       &#x3D;&gt;&#039;&#039;,<br>&#x2F;&#x2F;appears that this needs to be&#x2F;can be above “1” if we&#039;re using eav&#x2F;entity_increment_numeric<br>&#039;increment_per_store&#039;   &#x3D;&gt;&#039;0&#039;<br>));<br>我们调用了资源配置对象的“addEntityType”方法。这个方法的参数是实体类型（helloworld_eavblogpost）还有和这个类 型相关的参数。当你运行这个脚本以后，你会发现“eav_attribute_group”，“eav_attributeset”还有 “eav_entity_type”数据表中有了新的数据。访问以下URL<br><a href="http://127.0.0.1/Magento/helloworld/blog/eavRead/id/1">http://127.0.0.1/Magento/helloworld/blog/eavRead/id/1</a><br>你应该看到以下异常<br>SQLSTATE[42S02]: Base table or view not found: 1146 Table &#039;zend-magento.eavblog_posts&#039; doesn&#039;t exist</p>
<h4 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h4><p>我们已经告诉Magento我们的实体类型。接下来，我们要创建用来存储数据的数据表，并配置系统让Magento知道我们要用这些表。</p>
<p>如果你研究过Magento核心模块的资源配置脚本的话，比如core&#x2F;Mage&#x2F;CatalogInventory的配置脚本，你会看到很多用来创建数 据表的SQL语句。所幸的是，我们已经不必要这样做了。Magento提供的资源配置类有一个方法“createEntityTables”。我们可以用 这个方法来创建我们需要的数据表。同时这个方法也会在Magento的系统数据表中添加相应的配置数据。<br>$installer-&gt;createEntityTables(<br>$this-&gt;getTable(&#039;helloworld-eav&#x2F;blogpost&#039;)<br>);<br>“createEntityTables”有两个参数。第一个参数是基础表名（base table  name）。第二个参数是一系列选项。我们这里忽略了第二个参数，这些参数都是一些高级配置，超出了我们讨论的范围。在运行了上述脚本以后，你会发现数据 库中添加了如下数据表<br>eavblog_posts<br>eavblog_posts_datetime<br>eavblog_posts_decimal<br>eavblog_posts_int<br>eavblog_posts_text<br>eavblog_posts_varchar<br>同时，你会发现在“eav_attribute_set”表中多了一条数据<br>mysql&gt; select * from eav_attribute_set order by attribute_set_id DESC LIMIT 1 \G<br>*************************** 1. row ***************************<br>attribute_set_id: 63<br>entity_type_id: 31<br>attribute_set_name: Default<br>sort_order: 3<br>清空Magento缓存，重新访问如下URL<br><a href="http://127.0.0.1/Magento/helloworld/blog/eavRead/id/1">http://127.0.0.1/Magento/helloworld/blog/eavRead/id/1</a><br>你应该看到以下输出<br>Loading the blogpost with an ID of 1<br>array(0) { }</p>
<h4 id="添加属性"><a href="#添加属性" class="headerlink" title="添加属性"></a>添加属性</h4><p>创建资源配置的最后一步是告诉Magento我们的模型有哪些属性。这就和为单独的数据表添加列是一样的。【译者注：我们上面的输出是空的就是因为 我们虽然创建了EAV数据表，但是却没有创建EAV属性，就像创建了一张没有任何列的数据表，当然是空的。】和上面的步骤一样，Magento的资源配置 类提供了相应的帮助函数，“installEntities”和“getDefaultEntities”。</p>
<p>我们之前所做的是告诉Magento，我们创建了一个实体类型（Entity  Type），而现在，我们要配置这个实体类型使它能够和我们的模型相符合。这个方法名字有点搞“installEntities”，其实我们要做的是配置 这个实体。修改类“Zhlmmc_Helloworld_Model_Setup_Entity_Setup”<br>class Zhlmmc_Helloworld_Model_Setup_Entity_Setup extends Mage_Eav_Model_Entity_Setup {<br>public function getDefaultEntities()<br>{<br>return array (<br>&#039;helloworld_eavblogpost&#039; &#x3D;&gt; array(<br>&#039;entity_model&#039;      &#x3D;&gt; &#039;helloworld-eav&#x2F;eavblogpost&#039;,<br>&#039;attribute_model&#039;   &#x3D;&gt; &#039;&#039;,<br>&#039;table&#039;             &#x3D;&gt; &#039;helloworld-eav&#x2F;blogpost&#039;,<br>&#039;attributes&#039;        &#x3D;&gt; array(<br>&#039;title&#039; &#x3D;&gt; array(<br>&#x2F;&#x2F;the EAV attribute type, NOT a mysql varchar<br>&#039;type&#039;              &#x3D;&gt; &#039;varchar&#039;,<br>&#039;backend&#039;           &#x3D;&gt; &#039;&#039;,<br>&#039;frontend&#039;          &#x3D;&gt; &#039;&#039;,<br>&#039;label&#039;             &#x3D;&gt; &#039;Title&#039;,<br>&#039;input&#039;             &#x3D;&gt; &#039;text&#039;,<br>&#039;class&#039;             &#x3D;&gt; &#039;&#039;,<br>&#039;source&#039;            &#x3D;&gt; &#039;&#039;,<br>&#x2F;&#x2F; store scope &#x3D;&#x3D; 0<br>&#x2F;&#x2F; global scope &#x3D;&#x3D; 1<br>&#x2F;&#x2F; website scope &#x3D;&#x3D; 2<br>&#039;global&#039;            &#x3D;&gt; 0,<br>&#039;visible&#039;           &#x3D;&gt; true,<br>&#039;required&#039;          &#x3D;&gt; true,<br>&#039;user_defined&#039;      &#x3D;&gt; true,<br>&#039;default&#039;           &#x3D;&gt; &#039;&#039;,<br>&#039;searchable&#039;        &#x3D;&gt; false,<br>&#039;filterable&#039;        &#x3D;&gt; false,<br>&#039;comparable&#039;        &#x3D;&gt; false,<br>&#039;visible_on_front&#039;  &#x3D;&gt; false,<br>&#039;unique&#039;            &#x3D;&gt; false,<br>),<br>),<br>)<br>);<br>}<br>}<br>这里我们构建了一个数组，数组的元素是“key&#x2F;value”对。“key”就是实体类型的名字（以下代码参数是一样的 “$installer-&gt;addEntityType(&#039;helloworld_eavblogpost&#039;,…)”），“value”是一个数 组，用来描述这个实体类型。“value”数组的元素大部分你应该都见过，就不多解释了。这里要关注的是“attribute”元素，这个元素的值又是一 个数组。这个数组的内容就是我们定义的实体类型的属性，相当于普通数据表的列，比如这里的“title”。很可惜，我无法完整解释用来描述一个属性的数组 的内容。在这里，我们只要知道“type”就是这个属性的数据类型“varchar”。也就是说，这个属性的值将会被保存到 “eavblog_posts_varchar”数据表中。其他的很多元素都是和Magento的后台管理有关。Magento很多地方的UI是由模型控 制的，很多这些参数都是用来控制UI显示和系统设置。这样做的优点是灵活性提高，但是缺点是这些内容对于外部开发者都是不透明的。【译者注：我们是可以在 这个函数中返回多个实体类型的。如果返回多个实体类型，那就说明模块拥有多个模型。】</p>
<p>顺便说一下，Magento选择使用数组嵌套数组的形式来表示实体类型的属性很奇怪。因为Magento整个架构是非常面向对象的。这里的数据结构和系统的其他部分很不一样。</p>
<p>接下来我们需要修改安装脚本，添加如下代码<br>$installer-&gt;installEntities();<br>“installEntities”会调用“getDefaultEntities”方法来获取将要被配置的属性。当然你也可以把属性直接作为参数传给 “installEntities”，但是我觉得还是按照Magento的习惯来比较好。在调用“installEntitis”以后，Magento会 做下面两件事</p>
<ol>
<li>在“eav_attribute”表中添加“title”属性</li>
<li>在“eav_entity_attribute”表中添加一行<br>清空Magento缓存，刷新页面，你应该看到如下异常<br>SQLSTATE[23000]: Integrity constraint violation: 1217 Cannot delete or update a parent row: a foreign key constraint fails<br>那是因为我们之前已经调用过一次“createEntityTables”，再次调用的时候Magento会尝试先删除数据表，然后再创建。但是删除的时 候Magento没有考虑到外键的关系，先尝试删除了主表，所以就有了以上异常。为了简化教程的例子，我们暂时把 “createEntityTables”语句删了。再次刷新页面，你应该看到正常的输出。</li>
</ol>
<h4 id="给EAV模型添加数据"><a href="#给EAV模型添加数据" class="headerlink" title="给EAV模型添加数据"></a>给EAV模型添加数据</h4><p>到这里为止，我们的EAV模型已经创建好了，下面我们来为模型添加一些数据。在BlogController中添加以下方法<br>public function eavPopulateEntriesAction() {<br>for($i&#x3D;0;$i&lt;10;$i++) {<br>$weblog2 &#x3D; Mage::getModel(&#039;helloworld-eav&#x2F;eavblogpost&#039;);<br>$weblog2-&gt;setTitle(&#039;This is a test &#039;.$i);<br>$weblog2-&gt;save();<br>}<br>echo &#039;Done&#039;;<br>}<br>public function eavShowcollectionAction() {<br>$weblog2 &#x3D; Mage::getModel(&#039;helloworld-eav&#x2F;eavblogpost&#039;);<br>$entries &#x3D; $weblog2-&gt;getCollection()-&gt;addAttributeToSelect(&#039;title&#039;);<br>$entries-&gt;load();<br>foreach($entries as $entry)<br>{<br>&#x2F;&#x2F; var_dump($entry-&gt;getData());<br>echo &#039;</p>
<h1 id="039-entry-getTitle-039"><a href="#039-entry-getTitle-039" class="headerlink" title="&#039;.$entry-&gt;getTitle().&#039;"></a>&#039;.$entry-&gt;getTitle().&#039;</h1><p>&#039;;<br>}<br>echo &#039;<br>Done<br>&#039;;<br>}<br>记得添加模型集合<br>class Zhlmmc_Helloworld_Model_Resource_Eav_Mysql4_Blogpost_Collection extends Mage_Eav_Model_Entity_Collection_Abstract<br>{<br>protected function _construct()<br>{<br>$this-&gt;_init(&#039;helloworld-eav&#x2F;eavblogpost&#039;, &#039;helloworld-eav&#x2F;blogpost&#039;);<br>}<br>}<br>访问以下URL<br><a href="http://127.0.0.1/Magento/helloworld/blog/eavPopulateEntries">http://127.0.0.1/Magento/helloworld/blog/eavPopulateEntries</a><br>你应该看到正确的输出。细心一点的话你应该发现这里有两点比较特殊。第 一，“$weblog2-&gt;getCollection()-&gt;addAttributeToSelect(&#039;title&#039;)”，这里的 “title”是干什么的？因为EAV模型在数据库层面比较复杂，一个简单的查询都需要好多个SQL才能完成。所以在查询的时候你需要指明你想找什么，这 样可以节省系统资源。不过你也可以传入“*”，表示查找所有数据。第二，为什么“$this-&gt;_init”有两个参数？在我们以前的章节中，简单 模型的模型集合初始化的时候只需要传入模型的URI就可以了，为什么这里要两个参数呢？其实如果你仔细看了模型集合抽象类的代码的话，你会发现这样一段<br>if (is_null($resourceModel)) {<br>$resourceModel &#x3D; $model;<br>}<br>所以其实是需要模型的URI和资源模型的URI，但是由于我们前面章节的例子，这两个URI是一样的，所以省略了第二个参数。而这里，资源模型的URI和模型的URI是不一样的，所以不能省略。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>到这里，你应该对Magento整个系统的运作有所了解了。起码下一次你看到网店里面的某个商品部显示了，或者什么属性不对了，你知道去哪里找问题。除了本章介绍的内容以外EAV模型还有很多东西可以学习。下面是我打算在以后的文章中介绍的一些内容</p>
<ol>
<li>EAV属性：EAV模型的属性类型不局限于datatime, decimal, int, text和varchar。你可以创建自定义的数据类型。</li>
<li>集合筛选：对EAV模型的数据进行筛选不是看起来的那么简单，特别是当属性是自定义类型的情况下，我们需要在集合装载之前调用“addAttributeToFilter”方法。</li>
<li>Magento EAV模型继承：Magento在基本的EAV模型之上又创建了模型的继承关系，这些继承关系可以和网店的功能直接相关，也可以优化EAV模型的查询。<br>毫无疑问，EAV模型是Magento系统中最复杂的部分。不过你要始终相信一点，不管多复杂，它也就是程序。从哲学角度来讲，任何事物的产生都有特定的理由，你只需要搞清楚为什么。</li>
</ol>

        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.foolbird.net/1758.html" data-id="cm4fsa2cb0017plv49kmnbq97" class="article-share-link">Share</a>
      
        <a href="https://blog.foolbird.net/1758.html#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-1756" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/1756.html">深入理解Magento – 第五章 – Magento资源配置</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/1756.html" class="article-date">
  <time datetime="2011-10-22T06:19:55.000Z" itemprop="datePublished">2011-10-22</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%98%E6%A1%A3/">存档</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="深入理解Magento"><a href="#深入理解Magento" class="headerlink" title="深入理解Magento"></a>深入理解Magento</h1><p>作者：<a href="http://alanstorm.com/">Alan Storm</a><br>翻译：<a href="http://www.zhlmmc.com/">Hailong Zhang</a></p>
<h3 id="第五章-–-Magento资源配置"><a href="#第五章-–-Magento资源配置" class="headerlink" title="第五章 – Magento资源配置"></a>第五章 – Magento资源配置</h3><p>对于任何一个更新频繁的项目来说，保持开发环境和生产环境的数据库同步是件很头疼的事情。Magento提供了一套系统，用版本化的资源迁移脚本来解决这个问题。</p>
<p>上一章，我们为 Helloworld Blogpost 创建了一个模型。我们直接通过SQL语句“CREATE  TABLE”来创建数据表。在这一章，我们将为Helloworld模块创建一个资源配置（Setup  Resource）用于创建数据表。我们也会创建一个模块升级脚本，用来升级已经安装的模块。下面是我们要做的步骤</p>
<ol>
<li>在配置文件中添加资源配置</li>
<li>创建资源类文件</li>
<li>创建安装脚本</li>
<li>创建升级脚本</li>
<li>添加资源配置<br>修改Helloworld模型的config.xml<br>&#96;<resources><!-- ... -->
<helloworld_setup>
<setup>
<module>Zhlmmc_Helloworld</module>
<class>Zhlmmc_Helloworld_Model_Setup_Mysql4_Setup</class>
</setup>
<connection>
<use>core_setup</use>
</connection>
</helloworld_setup>
<!-- ... -->
</resources>`
<helloworld_setup>标签是用来唯一标识我们正在创建的资源配置。虽然不是强制要求，但是我们应该使用 “modelname_setup”来命名资源配置。<module>标签的内容是“Packagename_Modulename”。最 后，<class>标签的内容就是我们将要创建的资源配置类的类名。虽然对于基本的配置来说，没有必要创建一个单独的资源配置类，但是为了更 好的理解资源配置是如何工作的，我们的例子还是创建一个单独的类。
`File: app/code/local/Zhlmmc/Helloworld/Model/Setup/Mysql4/Setup.php
class Zhlmmc_Helloworld_Model_Setup_Mysql4_Setup extends Mage_Core_Model_Resource_Setup {
}`</li>
</ol>
<h4 id="创建安装脚本"><a href="#创建安装脚本" class="headerlink" title="创建安装脚本"></a>创建安装脚本</h4><p>下面我们将要创建一个安装脚本。这个安装脚本包含了“CREATE TABLE”等SQL语句。这个脚本将在模块初始化的被运行。首先我们来看一下模块的配置文件<br><code>&lt;modules&gt; &lt;Zhlmmc_Helloworld&gt; &lt;version&gt;0.1.0&lt;/version&gt; &lt;/Zhlmmc_Helloworld&gt; &lt;/modules&gt;</code><br>这一部分是所有config.xml都必须包含的。它包含了模块的名称，还有版本。我们的安装脚本的名字将基于这个版本号，“0.1.0”。创建以下文件<br><code>File: app/code/local/Zhlmmc/Helloworld/sql/helloworld_setup/mysql4-install-0.1.0.php echo &amp;#039;Running This Upgrade: &amp;#039;.get_class($this).&quot;\n   \n&quot;; die(&quot;Exit for now&quot;); </code><br>文件路径中的“helloworld_setup”应该和上文在config.xml中添加的<helloworld_setup>一致。文件名中的“0.1.0”就是模块的版本号。清空Magento缓存，访问任何URL，你应该看到以下内容<br><code>Running This Upgrade: Zhlmmc_Helloworld_Model_Setup_Mysql4_Setup Exit for now ...</code><br>这说明我们的安装脚本已经被运行了。我们先不放SQL脚本在这里，先把创建一个资源配置的流程走完。移除“die()”语句，重新装载页面，你应该看到你的Upgrade语句在页面的顶部，再次刷新页面，页面应该正常显示了。</p>
<h4 id="资源版本"><a href="#资源版本" class="headerlink" title="资源版本"></a>资源版本</h4><p>Magento的资源配置系统允许你直接拷贝安装脚本和升级脚本到服务器上，Magento会根据当前模块的版本自动运行相应的脚本。这样你就只需要维护一份数据库迁移脚本。我们先来看看“core_resource”数据表<br>mysql&gt; select code,version from core_resource;<br>+————————-+————+<br>| code                    | version    |<br>+————————-+————+<br>| adminnotification_setup | 1.0.0      |<br>| admin_setup             | 0.7.2      |<br>| alipay_setup            | 0.9.0      |<br>| api_setup               | 0.8.1      |<br>| backup_setup            | 0.7.0      |<br>| bundle_setup            | 0.1.11     |<br>| canonicalurl_setup      | 0.1.0      |<br>| catalogindex_setup      | 0.7.10     |<br>| cataloginventory_setup  | 0.7.5      |<br>| catalogrule_setup       | 0.7.8      |<br>| catalogsearch_setup     | 0.7.7      |<br>| catalog_setup           | 1.4.0.0.21 |<br>| checkout_setup          | 0.9.5      |<br>| chronopay_setup         | 0.1.0      |<br>| cms_setup               | 0.7.13     |<br>| compiler_setup          | 0.1.0      |<br>| contacts_setup          | 0.8.0      |<br>| core_setup              | 0.8.26     |<br>| cron_setup              | 0.7.1      |<br>| customer_setup          | 1.4.0.0.6  |<br>| cybermut_setup          | 0.1.0      |<br>| cybersource_setup       | 0.7.0      |<br>| dataflow_setup          | 0.7.4      |<br>| directory_setup         | 0.8.10     |<br>| downloadable_setup      | 0.1.16     |<br>| eav_setup               | 0.7.15     |<br>| eway_setup              | 0.1.0      |<br>| flo2cash_setup          | 0.1.1      |<br>| giftmessage_setup       | 0.7.2      |<br>| googleanalytics_setup   | 0.1.0      |<br>| googlebase_setup        | 0.1.1      |<br>| googlecheckout_setup    | 0.7.3      |<br>| googleoptimizer_setup   | 0.1.2      |<br>| helloworld_setup        | 0.1.0      |<br>| ideal_setup             | 0.1.0      |<br>| index_setup             | 1.4.0.2    |<br>| log_setup               | 0.7.7      |<br>| moneybookers_setup      | 1.2        |<br>| newsletter_setup        | 0.8.2      |<br>| oscommerce_setup        | 0.8.10     |<br>| paybox_setup            | 0.1.3      |<br>| paygate_setup           | 0.7.1      |<br>| payment_setup           | 0.7.0      |<br>| paypaluk_setup          | 0.7.0      |<br>| paypal_setup            | 0.7.4      |<br>| poll_setup              | 0.7.2      |<br>| productalert_setup      | 0.7.2      |<br>| protx_setup             | 0.1.0      |<br>| rating_setup            | 0.7.2      |<br>| reports_setup           | 0.7.10     |<br>| review_setup            | 0.7.6      |<br>| salesrule_setup         | 0.7.12     |<br>| sales_setup             | 0.9.56     |<br>| sendfriend_setup        | 0.7.4      |<br>| shipping_setup          | 0.7.0      |<br>| sitemap_setup           | 0.7.2      |<br>| strikeiron_setup        | 0.9.1      |<br>| tag_setup               | 0.7.5      |<br>| tax_setup               | 0.7.11     |<br>| usa_setup               | 0.7.1      |<br>| weee_setup              | 0.13       |<br>| widget_setup            | 1.4.0.0.0  |<br>| wishlist_setup          | 0.7.7      |<br>+————————-+————+<br>63 rows in set (0.00 sec)<br>这张表包含了系统中所有安装的模块和模块的版本。你可以看到我们的模块<br><code>| helloworld_setup        | 0.1.0      |</code><br>Magento就是根据这个版本来判断是否需要运行升级脚本的。这里“helloworld_setup”版本“0.1.0”，而我们的安装脚本也是 “0.1.0”，所以Magento不会再运行该脚本。如果你需要重新运行安装脚本（在开发的时候常用到），只要删除表中相应模块的数据就行了。让我们来 试试看<br>DELETE from core_resource where code &#x3D; &#039;helloworld_setup&#039;;<br>这次我们将通过安装脚本来创建数据表，所以我们也要删除之前创建的数据表<br>DROP TABLE blog_posts;<br>添加以下代码到我们的安装脚本<br>$installer &#x3D; $this;<br>$installer-&gt;startSetup();<br>$installer-&gt;run(“<br>CREATE TABLE <code>&#123;$installer-&gt;getTable(&amp;#039;helloworld/blogpost&amp;#039;)&#125;</code> (<br><code>blogpost_id</code> int(11) NOT NULL auto_increment,<br><code>title</code> text,<br><code>post</code> text,<br><code>date</code> datetime default NULL,<br><code>timestamp</code> timestamp NOT NULL default CURRENT_TIMESTAMP,<br>PRIMARY KEY  (<code>blogpost_id</code>)<br>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;<br>INSERT INTO <code>&#123;$installer-&gt;getTable(&amp;#039;helloworld/blogpost&amp;#039;)&#125;</code>  VALUES (1,&#039;My New Title&#039;,&#039;This is a blog post&#039;,&#039;2009-07-01  00:00:00&#039;,&#039;2009-07-02 23:12:30&#039;);<br>“);<br>$installer-&gt;endSetup();<br>清空Magento缓存，访问任何URL，你应该发现“blog_posts”表又被建立了，拥有一条数据。</p>
<h4 id="解剖配置脚本"><a href="#解剖配置脚本" class="headerlink" title="解剖配置脚本"></a>解剖配置脚本</h4><p>让我们来分析一下上面的代码。【译者注：作者在文中混用了“install script”，“upgrade script”和“setup script”。我在翻译的时候尽量分清。配置脚本包含了安装脚本和升级脚本。】先看第一行<br>$installer &#x3D; $this;<br>这个“$this”是什么呢？每一个配置脚本都是属于某个资源配置类（Setup Resource  class），比如上面我们创建的“Zhlmmc_Helloworld_Model_Setup_Mysql4_Setup”。这些脚本都是在这个资源 配置类的上下文环境中运行的。所以“$this”就是指资源配置类的实例。虽然不是强制的，但是大多数核心模块的资源配置类都用“$installer” 来代替“$this”，就和我们这里做的一样。虽然我们说不是强制的，但是我们最好还是遵守这个约定，除非你有一个很好的理由。</p>
<p>接下来看下面两个调用<br>$installer-&gt;startSetup();<br>&#x2F;&#x2F;…<br>$installer-&gt;endSetup();<br>如果你打开“Mage_Core_Model_Resource_Setup”类（也就是我们创建的资源配置类的父类）的源码，你将会看到这两个方法做了一些SQL准备工作<br>public function startSetup()<br>{<br>$this-&gt;_conn-&gt;multi_query(“SET SQL_MODE&#x3D;&#039;&#039;;<br>SET @OLD_FOREIGN_KEY_CHECKS&#x3D;@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS&#x3D;0;<br>SET @OLD_SQL_MODE&#x3D;@@SQL_MODE, SQL_MODE&#x3D;&#039;NO_AUTO_VALUE_ON_ZERO&#039;;<br>“);<br>return $this;<br>}<br>public function endSetup()<br>{<br>$this-&gt;_conn-&gt;multi_query(“<br>SET SQL_MODE&#x3D;IFNULL(@OLD_SQL_MODE,&#039;&#039;);<br>SET FOREIGN_KEY_CHECKS&#x3D;IFNULL(@OLD_FOREIGN_KEY_CHECKS,0);<br>“);<br>return $this;<br>}<br>真正的配置逻辑是在“run”方法中<br>$installer-&gt;run(…);<br>这个方法的参数就是你要运行的SQL。你可以包含任意数量的SQL，用分号隔开。你可能注意到了以下语句<br>$installer-&gt;getTable(&#039;helloworld&#x2F;blogpost&#039;)<br>【译者注：你的第一反应是什么？是不是联想到config.xml里面下面这段代码？<br><helloworld_mysql4><br><class>Zhlmmc_Helloworld_Model_Resource_Mysql4</class><br><entities><br><blogpost></p>
<table>blog_posts</table>
</blogpost>
</entities>
</helloworld_mysql4>
这里“helloworld/blogpost”就是我们要创建的数据表的URI。Magento先用“helloworld”找到模块，得到资源模块 “helloworld_mysql4”，然后在资源模块下面通过“blogpost”找到类名“blog_posts”。】很显然，你可以用常量 “blog_posts”来代替调用“getTable”，但是调用这个方法可以保证即使用户更改了配置文件中的数据表名字，你的配置脚本依然能运行。 “Mage_Core_Model_Resource_Setup”类有很多类似这样的帮助函数。学习这些函数最好的方法就是阅读Magento核心模块 的资源配置类代码。

<h4 id="模块升级脚本"><a href="#模块升级脚本" class="headerlink" title="模块升级脚本"></a>模块升级脚本</h4><p>上面我们说过配置脚本包括安装脚本和升级脚本。讲完了安装脚本，我们来讲升级脚本。安装脚本是在第一次安装模块的时候使用的，而升级脚本顾名思义就是在升级模块的时候使用。Magento的资源配置系统使用了版本化的方式来升级模块。</p>
<p>首先要说明的是，在安装模块的时候Magento会执行一次安装脚本，然后Magento再也不会为该模块执行任何安装脚本了。如果你要更新模块的数据表就要通过升级脚本来执行。除了命名方式以外，升级脚本和安装脚本并没有太大的不同。</p>
<p>创建升级脚本如下<br>File: app&#x2F;code&#x2F;local&#x2F;Zhlmmc&#x2F;Helloworld&#x2F;sql&#x2F;helloworld_setup&#x2F;mysql4-upgrade-0.1.0-0.2.0.php<br>echo &#039;Testing our upgrade script (mysql4-upgrade-0.1.0-0.2.0.php) and  halting execution to avoid updating the system version number<br>&#039;;<br>die();<br>升级脚本和安装脚本是放在相同目录下面的，但是命名方式不同。首先是“upgrade”关键词。其次，你会发现这里我们有两个版本号，用“-”分开。第一 个版本号“0.1.0”是指从哪个版本升级（起始版本），第二个版本号“0.2.0”是指要升级到哪个版本（目标版本）。</p>
<p>清空Magento缓存，请求任何一个URL，你会发现没有任何配置脚本被运行。那是因为，第一，我们已经运行过安装脚本，第二，目前我们模块的版本是 “0.1.0”，所以Magento不会运行我们要升级到“0.2.0”的升级脚本。要让Magento运行这个升级脚本，我们得修改配置文件中的版本号<br><modules><br><Zhlmmc_Helloworld><br><version>0.2.0</version><br></Zhlmmc_Helloworld><br></modules><br>清空Magento缓存，重新请求页面，你会看到升级脚本的输出。【译者注：作者在这里引入了第二个升级到“0.1.5”的升级脚本，我觉得并没有必要，我来直接总结一下Magento升级的步骤</p>
<ol>
<li>从数据表“core_resource”中获得当前模块的安装版本</li>
<li>从配置文件中获得当前模块的版本</li>
<li>如果两个版本一样，那么什么都不做</li>
<li>如果#2的版本号小于#1的版本号，我也不知道Magento会干什么，理论上是不可能出现的情况</li>
<li>如果#2的版本号大于#1的版本号，那么开始升级程序</li>
<li>在配置脚本文件夹内（在上面的例子中是“helloworld_setup”）把所有升级脚本加入队列</li>
<li>在队列内，按照升级脚本的起始版本排序，升序</li>
<li>循环队列</li>
<li>如果队列中当前脚本的起始版本不等于“core_resource”数据表中当前模块的版本号，那么跳过该脚本</li>
<li>如果队列中当前脚本的起始版本等于“core_resource”数据表中当前模块的版本号并且目标版本小于等于#2的版本号，那么执行该脚本。</li>
<li>循环队列结束，升级结束<br>值得注意的是第10步，每次执行一个升级脚本，“core_resource”数据表中的版本号都会被更新。所以如果我们有两个升级文件“0.1.0-0.1.5”和“0.1.0-0.2.0”，只有一个升级文件会被执行。<br>】</li>
</ol>
<p>下面我们来为升级脚本添加实质内容<br>$installer &#x3D; $this;<br>$installer-&gt;startSetup();<br>$installer-&gt;run(“<br>ALTER TABLE <code>&#123;$installer-&gt;getTable(&amp;#039;helloworld/blogpost&amp;#039;)&#125;</code><br>CHANGE post post text not null;<br>“);<br>$installer-&gt;endSetup();<br>清空Magento缓存，刷新页面，你应该看到升级脚本的输出。如果没有，请你对照上面讲的Magento升级的步骤查找错误。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这一章我们讲解了Magento是如何处理模块数据表的安装和升级的。Magento的资源配置系统使用版本化的升级脚本，这样就保证了不同版本的 模块可以使用同一套的升级脚本，便于维护。我们后面的章节也会提到这种升级方式的优点，特别是对于使用EAV模型的模块来说，这个优点更为明显。 </p>

        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.foolbird.net/1756.html" data-id="cm4fsa2cb0015plv41u9nfqkm" class="article-share-link">Share</a>
      
        <a href="https://blog.foolbird.net/1756.html#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-1754" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/1754.html">深入理解Magento – 第四章 – 模型和ORM基础</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/1754.html" class="article-date">
  <time datetime="2011-10-22T06:18:04.000Z" itemprop="datePublished">2011-10-22</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%98%E6%A1%A3/">存档</a>
  </div>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="深入理解Magento"><a href="#深入理解Magento" class="headerlink" title="深入理解Magento"></a>深入理解Magento</h1><p>作者：<a href="http://alanstorm.com/">Alan Storm</a><br>翻译：<a href="http://www.zhlmmc.com/">Hailong Zhang</a></p>
<h3 id="第四章-–-模型和ORM基础"><a href="#第四章-–-模型和ORM基础" class="headerlink" title="第四章 – 模型和ORM基础"></a>第四章 – 模型和ORM基础</h3><p>对于任何一个MVC架构，模型（Model）层的实现都是占据了很大一部分。对于Magento来说，模型占据了一个更加重要的位置，因为它常常包含了一部分商业逻辑代码（可以说它对，也可以说它错）。这些代码在其他的MVC框架中往往出现在控制器或者帮助函数中。</p>
<h4 id="传统的PHP-MVC架构中的模型"><a href="#传统的PHP-MVC架构中的模型" class="headerlink" title="传统的PHP MVC架构中的模型"></a>传统的PHP MVC架构中的模型</h4><p>本来MVC的定义就不是很清晰，不同的人有不同的看法，而对于模型的定义争议就更多了。在MVC模式被广泛采用之前，PHP程序员往往通过SQL语 句直接操作数据库。也有些程序员通过一个SQL抽象层来操作数据库（比如AdoDB）。程序员往往关注SQL语句本身，而不是和数据相关的对象。</p>
<p>虽然直接操作SQL的方式一直被病诟，但是很多PHP框架还是以SQL为中心的。模型层提供了一系列对象，抽象&#x2F;封装了数据操作，但是程序员最终还是需为模型层对象写SQL语句操作数据库。</p>
<p>还有一些框架回避了SQL，使用了对象关系映射（Object Relational  Mapping，ORM）来解决这个问题。使用这个方法的话，程序员不用关注SQL，而只需要和对象打交道。我们可以操作一个对象的属性，当“Save” 方法被调用的时候，对象的属性会作为数据自动的被写入数据库。有些ORM框架会根据数据表的信息自动推测对象的属性，也有框架要求用户显示的生命对象属性 和表的关系。比较有名的ORM框架有ActiveRecord等等。【译者注：ActiveRecord源自Ruby on  Rails，不过现在PHP也有了】</p>
<p>关于ORM的概念，我就解释到这里。但是和许多计算机领域的其他概念一样，ORM的定义也越来越模糊了。我不想在这片文章中讨论关于ORM的争议，所以我说的ORM就是那个最基本的ORM概念。</p>
<h4 id="Magento的模型"><a href="#Magento的模型" class="headerlink" title="Magento的模型"></a>Magento的模型</h4><p>Magento理所当然的也追随潮流应用了ORM。虽然Magento自带的Zend框架提供了SQL抽象层，但是在大多数情况下我们将通过 Magento自带的模型和我们自己的模型来进行数据访问。他和视图层（View）一样，Magento的模型层也不是简单的ORM，而是一个高度灵活， 高度抽象甚至有点令人费解。</p>
<h4 id="解剖Magento的模型"><a href="#解剖Magento的模型" class="headerlink" title="解剖Magento的模型"></a>解剖Magento的模型</h4><p>大部分的Magento模型分为两类。第一类是基本的ActiveRecord类型，一张表一个对象的模型。第二类是Entity  Attribute  Value（EAV）模型。【译者注：EAV翻译成“实体属性值”有点词不达意，还是就叫EAV的好】Magento自己定义了一个数据类型叫做模型集合 （Model  Collection）。顾名思义，模型集合就是一个对象里面包含了很多模型对象。Magento的创造者Varien团队实现了PHP类库的标准接 口，“IteratorAggregate”，“Countable”。这样模型集合就能调用这些方法，这也是模型集合和数组的区别。</p>
<p>Magento的模型并不直接访问数据库。每一个模型都有一个资源模型（Resource  Model），每一个资源模型拥有两个适配器（Adapter），一个读，一个写。这样的话逻辑模型和数据库访问就分开了，所以从理论上讲更改底层数据库 只需要重写适配器就可以了，所有上层代码都不需要更改。<br>创建一个基本模型</p>
<p>【译者注：从这一章开始我用我自己的例子替换了Alan的例子】继续我们Hello World的例子。在Hello World模块中创建BlogController.php如下<br><code>class Zhlmmc_Helloworld_BlogController extends Mage_Core_Controller_Front_Action &#123; public function indexAction() &#123; echo &amp;#039;Hello Blog&amp;#039;; &#125; &#125;</code><br>访问以下URL<br><code>http://127.0.0.1/Magento/helloworld/blog</code><br>你应该看到“Hello Blog”输出。</p>
<h4 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h4><p>我们可以通过Magento自带的方法创建或者修改数据库，但是为了不引入过多新内容，我们暂且手工创建一张表。在你的数据库中执行以下语句<br><code>CREATE TABLE </code>blog_posts<code>(</code>blogpost_id<code>int(11) NOT NULL auto_increment,</code>title<code>text,</code>post<code>text,</code>date<code>datetime default NULL,</code>timestamp<code> timestamp NOT NULL default CURRENT_TIMESTAMP, PRIMARY KEY  (</code>blogpost_id<code>) );</code><br><code>INSERT INTO </code>blog_posts<code> VALUES (1,&amp;#039;My New Title&amp;#039;,&amp;#039;This is a blog post&amp;#039;,&amp;#039;2009-07-01 00:00:00&amp;#039;,&amp;#039;2009-07-02 23:12:30&amp;#039;);</code><br>这里我们创建了一张名为“blog_posts”的表，并填充了一条数据。</p>
<h4 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h4><p>要设置一个模型一共有以下四个步骤</p>
<ol>
<li><p>启用模型</p>
</li>
<li><p>启用资源模型</p>
</li>
<li><p>在资源模型中添加实体（Entity）。对于简单的模型来说，实体就是数据表的名字</p>
</li>
<li><p>为资源模型设置读、写适配器<br>在进行这些步骤之前，我们先来看假设这些步骤已经做完了，我们怎么用一个模型。在Magento中，我们用以下的方式来实例化一个模型<br><code>$model = Mage::getModel(&amp;#039;helloworld/blogpost&amp;#039;);</code><br>和我们以前讲过的“Mage::getHelper()”的原理类似，这里Magento也是通过全局配置去查找模型的类名。模型的类名和我们以前讲过的 块类名一样，都是分组类名。这里参数的前半部分“helloworld”是组名（Group  Name），后半部分“blogpost”是半类名（Class Name）【译者注：我将“Class  Name”翻译成半类名是为了和类名区分开来】。具体步骤如下</p>
</li>
<li><p>从全局配置“&#x2F;global&#x2F;models&#x2F;GROUP_NAME&#x2F;class”获得基本类名“Zhlmmc_Helloworld_Model”</p>
</li>
<li><p>检查全局配置“&#x2F;global&#x2F;models&#x2F;GROUP_NAME&#x2F;rewrite&#x2F;CLASS_NAME”是否设置，如果有那么这个节点的值将被作为类名实例化</p>
</li>
<li><p>否则，最终的类名将是基本类名加上半类名，也就是“Zhlmmc_Helloworld_Model_Blogpost”</p>
</li>
</ol>
<h4 id="启用模型"><a href="#启用模型" class="headerlink" title="启用模型"></a>启用模型</h4><p>修改模块的config.xml<br>&#96;<global></p>
<!-- ... -->
<models>
<helloworld>
<class>Zhlmmc_Helloworld_Model</class>
<!--
need to create our own resource, can&#039;t just
use core_mysql4
-->
<resourceModel>helloworld_mysql4</resourceModel>
</helloworld>
</models>
<!-- ... -->
</global>`
标签<helloworld />就是组名，也应该和模块名一致。<class />标签的内容是基本类名，所有Helloworld模块的模型都用这个基本类名,命名方式如下
`Packagename_Modulename_Model`
<resourceModel />标签指明了这个模块的模型要用哪个资源模型。这个标签的内容是组名加上“mysql4”我们将在后面详细介绍资源模型。

<p>现在让我们来实例化一个模型看看，修改indexAction方法<br><code>public function indexAction() &#123; $blogpost = Mage::getModel(&amp;#039;helloworld/blogpost&amp;#039;); echo get_class($blogpost); &#125;</code><br>清空Magento缓存，刷新页面，你应该看到一个类似这样的异常（请先打开Magento的<a href="http://alanstorm.com/magento_log_and_developer_mode">开发模式</a>）<br><code>include(Zhlmmc\Helloworld\Model\Blogpost.php)  [[function.include](&amp;#039;function.include&amp;#039;)]: failed  to open stream: No such file or directory</code><br>原因很简单，就是Magento尝试去实例化“Zhlmmc_Helloworld_Model_Blogpost”，但是它在Helloworld模块的文件夹里面找不到这个类。所以我们现在来创建这个类<br><code>File: app/code/local/Zhlmmc/Helloworld/Model/Blogpost.php class Zhlmmc_Helloworld_Model_Blogpost extends Mage_Core_Model_Abstract &#123; protected function _construct() &#123; $this-&gt;_init(&amp;#039;helloworld/blogpost&amp;#039;); &#125; &#125;</code><br>刷新页面，你应该看到页面上显示“Zhlmmc_Helloworld_Model_Blogpost”。所有的模型都必须继承 “Mage_Core_Model_Abstract”类。这个抽象类强制你实现一个方法“_construct”（注意：这个不是PHP的构造行数 “__construct”）。这个方法应该调用父类已经定义好的“_init”方法，参数是资源模型的URI，也就是我们要告诉模型使用哪个资源模型。 我们将在解释资源模型的时候再解释这个URI。</p>
<h4 id="启用资源模型并添加实体"><a href="#启用资源模型并添加实体" class="headerlink" title="启用资源模型并添加实体"></a>启用资源模型并添加实体</h4><p>好了，我们设置好了模型，下面我们要为模型设置资源模型。资源模型才是真正和数据库对话的组件。在模型的配置中，有一段这样的代码<br><code>&lt;resourceModel&gt;helloworld_mysql4&lt;/resourceModel&gt;</code><br><resourceModel />的值将被用来实例化资源模型。我们不需要显式的调用资源模型，但是当一个模型需要访问数据库的时候，Magento会自动实例化一个资源模型来使用。<br><code>Mage::getResourceModel(&amp;#039;helloworld/blogpost&amp;#039;);</code><br>这里“helloworld&#x2F;blogpost”就是我们给模型的“_init”传入的参数。“helloworld”是组名，“blogpost”是模 型的半类名。“Mage::getResourceModel”方法将以“helloworld&#x2F;blogpost”为URI在全局配置中找 到<resourceModel>标签的值，在这里是“helloworld_mysql4”。然后Magento会用 URI“helloworld_mysql4&#x2F;blogpost”去实例化资源模型类。实例化的过程和我们前面讲的模型的实例化是一样的，所以我们也需要 在config.xml中添加资源模型的声明<br>&#96;<global></p>
<!-- ... -->
<models>
<!-- ... -->
<helloworld_mysql4>
<class>Zhlmmc_Helloworld_Model_Resource_Mysql4</class>
</helloworld_mysql4>
</models>
</global>`
这里我们可以看到，资源模型的声明也是放在<models />下面的。有点搞，但是也不必深究了，Magento就这么定义的。<class />标签的值是所有资源模型类的基本类名，命名方式如下
`Packagename_Modulename_Model_Resource_Mysql4`
好了，我们已经配置了资源模型，我们来试试装载一些数据。修改indexAction如下
`public function indexAction() {
$params = $this->getRequest()->getParams();
$blogpost = Mage::getModel(&#039;helloworld/blogpost&#039;);
echo("Loading the blogpost with an ID of ".$params[&#039;id&#039;]."
");
$blogpost->load($params[&#039;id&#039;]);
$data = $blogpost->getData();
var_dump($data);
}`
清空Magento缓存，访问下面的页面
`http://127.0.0.1/Magento/helloworld/blog/index/id/1`
你应该看到一个类似下面这样的异常
`include(Zhlmmc\Helloworld\Model\Resource\Mysql4\Blogpost.php)  [function.include]: failed to open stream: No such file or directory`
我想你看到这里也明白了，我们要为模型添加一个资源类，添加如下文件
`File: app/code/local/Zhlmmc/Helloworld/Model/Resource/Mysql4/Blogpost.php
class Zhlmmc_Helloworld_Model_Resource_Mysql4_Blogpost extends Mage_Core_Model_Mysql4_Abstract{
protected function _construct()
{
$this->_init(&#039;helloworld/blogpost&#039;, &#039;blogpost_id&#039;);
}
}`
这里“_init”方法的第一个参数这个资源模型将要使用的数据表的URI，第二个参数是数据表中的列名。这个列的内容必须唯一，往往是数据表的主键。

<h4 id="为资源模型添加实体"><a href="#为资源模型添加实体" class="headerlink" title="为资源模型添加实体"></a>为资源模型添加实体</h4><p>刷新页面，你是不是得到下面的异常？<br><code>Can&amp;#039;t retrieve entity config: helloworld/blogpost</code><br>那是因为我们的资源文件现在还是一个空壳，并没有和数据库联系起来。现在我们来把资源模型和我们的表联系起来，修改config.xml如下<br>&#96;<global></p>
<!-- ... -->
<models>
<!-- ... -->
<helloworld_mysql4>
<class>Zhlmmc_Helloworld_Model_Resource_Mysql4</class>
<entities>
<blogpost>
<table>blog_posts</table>
</blogpost>
</entities>
</helloworld_mysql4>
</models>
</global>`
我们前面设置了资源模型使用的数据表的URI是“helloworld/blogpost”，那么Magento会把“helloworld”作为组 名，“blogpost”作为实体名，也就是<blogpost>。在Magento的简单模型中（也就是继承 Mage_Core_Model_Mysql4_Abstract的模型），一个实体对应一张数据表。我们的数据表是“blog_posts”，所以这 里<table />标签的内容就是“blog_posts”。

<p>清空Magento缓存，再次刷新页面，你应该看到以下内容<br><code>Loading the blogpost with an ID of 1 array(5) &#123; [&quot;blogpost_id&quot;]=&gt; string(1) &quot;1&quot; [&quot;title&quot;]=&gt; string(12)  &quot;My New Title&quot; [&quot;post&quot;]=&gt; string(19) &quot;This is a blog post&quot;  [&quot;date&quot;]=&gt; string(19) &quot;2009-07-01 00:00:00&quot; [&quot;timestamp&quot;]=&gt;  string(19) &quot;2009-07-02 23:12:30&quot; &#125;</code></p>
<h4 id="设置读写适配器"><a href="#设置读写适配器" class="headerlink" title="设置读写适配器"></a>设置读写适配器</h4><p>在上面的例子中，我们已经可以从数据库中取数据了，但是我们却没有为资源模型设置读写适配器，怎么回事呢？原因很简单，那就是因为Magento会为没有适配器的资源模型启用默认适配器。我们也可以显式的配置默认的适配器<br>&#96;<global></p>
<!-- ... -->
<resources>
<helloworld_write>
<connection>
<use>default_write</use>
</connection>
</helloworld_write>
<helloworld_read>
<connection>
<use>default_read</use>
</connection>
</helloworld_read>
</resources>
</global>`
在<resources  />标签下面有两个部分，一个读，一个写。标签名字中的“hellworld”是我们定义的组名【译者注：在资源模型的“_init”函数中传入的 数据表的URI  “helloworld/blogpost”的前半部分就是适配器名字的前半部分】。从这里我们也可以看出来一个资源组对应一对适配器。清空 Magento缓存，刷新浏览器，你应该看到和刚才相同的页面。【译者注：如果你去全局配置中找“core_read”你会发现 “default_read”，然后是“default_setup”
`<default_setup>
<connection>
<model>mysql4</model>
<initStatements>SET NAMES utf8</initStatements>
<type>pdo_mysql</type>
<host>localhost</host>
<username>root</username>
<password>admin</password>
<dbname>zend-magento</dbname>
<active>1</active>
</connection>
</default_setup>`
这才是最终和数据库连接的详细信息。如果你再往下深究，你会发现全局配置有这么一段
`<resource>
<connection>
<types>
<pdo_mysql>
<class>Mage_Core_Model_Resource_Type_Db_Pdo_Mysql</class>
</pdo_mysql>
</types>
</connection>
</resource>`
所以，“Mage_Core_Model_Resource_Type_Db_Pdo_Mysql”才是最终连接数据库的类。如果我们更换数据库的话，我们要重写一个相似的类来连接别的数据库。
】

<h4 id="基本模型操作"><a href="#基本模型操作" class="headerlink" title="基本模型操作"></a>基本模型操作</h4><p>所有的模型最终都继承自类“Varien_Object”。这个类属于Magento的系统类库，不属于Magento的核心模块。你可以在以下位置找到这个类<br><code>lib/Varien/Object.php</code><br>Magento模型的数据保存在“_data”属性中，这个属性是“protected”修饰的。父类“Varian_Object”定义了一些函数用来 取出这些数据。我们上面的例子用了“getData”，这个方法返回一个数组，数组的元素是“key&#x2F;value”对。【译者注：其实就是数据表中一行的 数据，“key”就是列名，“value”就是值】我们可以传入一个参数获取某个具体的“key”的值。<br><code>$model-&gt;getData(); $model-&gt;getData(&amp;#039;title&amp;#039;);</code><br>还有一个方法是“getOrigData”，这个方法会返回模型第一次被赋予的值。【译者注：因为模型在初始化以后，值可以被修改，这个方法就是拿到那个最原始的值】<br><code>$model-&gt;getOrigData(); $model-&gt;getOrigData(&amp;#039;title&amp;#039;);</code><br>“Varien_Object”也实现了一些PHP的特殊函数，比如神奇的“__call”。你可以对任何一个属性调用“get, set, unset, has”方法<br><code>$model-&gt;getBlogpostId(); $model-&gt;setBlogpostId(25); $model-&gt;unsetBlogpostId(); if($model-&gt;hasBlogpostId())&#123;...&#125;</code><br>这里的方法名中的属性名字符合<a href="http://en.wikipedia.org/wiki/CamelCase">“camelcase”命名规则</a>【译 者注：简单的说就是Java的命名规则，每个单词的第一个字母大写，第一个字母可以大写也可以小写】。为了有效的利用这些方便的方法，我们在定义数据表列 名的时候要用小写，并用下划线作为分隔符，比如“blogpost_id”。在最近的Magento版本中，这个规则已经被弱化，为了实现PHP的 “ArrayAccess”接口<br><code>$id = $model-&gt;[&amp;#039;blogpost_id&amp;#039;]; $model-&gt;[&amp;#039;blogpost_id&amp;#039;] = 25; //etc...</code><br>也就是说，你会在Magento中同时看到这两种技巧的使用。</p>
<h4 id="Magento中的CRUD操作"><a href="#Magento中的CRUD操作" class="headerlink" title="Magento中的CRUD操作"></a>Magento中的CRUD操作</h4><p>Magento模型通过“load, save, delete”三个方法来支持基本的Create，Read，Update和Delete操作。我们在上面已经使用过“load”方法了。这个方法的参数就是要装在的数据记录的“id”。<br><code>$blogpost-&gt;load(1);</code><br>“save”方法可以用来创建新数据或者修改已有数据。我们在BlogController.php中添加如下方法<br><code>public function createNewPostAction() &#123; $blogpost = Mage::getModel(&amp;#039;helloworld/blogpost&amp;#039;); $blogpost-&gt;setTitle(&amp;#039;Code Post!&amp;#039;); $blogpost-&gt;setPost(&amp;#039;This post was created from code!&amp;#039;); $blogpost-&gt;save(); echo &amp;#039;post created&amp;#039;; &#125;</code><br>访问以下URL<br><code>http://127.0.0.1/Magento/helloworld/blog/createNewPost</code><br>现在你数据表中应该有两条数据了。下面来修改一条数据<br><code>public function editFirstPostAction() &#123; $blogpost = Mage::getModel(&amp;#039;helloworld/blogpost&amp;#039;); $blogpost-&gt;load(1); $blogpost-&gt;setTitle(&quot;The First post!&quot;); $blogpost-&gt;save(); echo &amp;#039;post edited&amp;#039;; &#125;</code><br>最后，我们来删除一条数据<br><code>public function deleteFirstPostAction() &#123; $blogpost = Mage::getModel(&amp;#039;helloworld/blogpost&amp;#039;); $blogpost-&gt;load(1); $blogpost-&gt;delete(); echo &amp;#039;post removed&amp;#039;; &#125;</code></p>
<h4 id="模型集合"><a href="#模型集合" class="headerlink" title="模型集合"></a>模型集合</h4><p>上面的例子我们只是演示了对单个数据操作，现在我们来看看如何同时操作多条记录。我们上面已经讲过，每个Magento的模型都有一个独特的模型集 合。这些模型集合实现了PHP的“IteratorAggregate”和“Countable”接口，也就是他们可以作为“count”函数的参数，并 且可以在“for each”语句中使用。</p>
<p>现在让我们来看看如何使用模型集合，在Blog控制器中添加如下方法<br>&#96;public function showAllBlogPostsAction() {<br>$posts &#x3D; Mage::getModel(&#039;helloworld&#x2F;blogpost&#039;)-&gt;getCollection();<br>foreach($posts as $blog_post){<br>echo &#039;</p>
<h3 id="039-blog-post-getTitle-039"><a href="#039-blog-post-getTitle-039" class="headerlink" title="&#039;.$blog_post-&gt;getTitle().&#039;"></a>&#039;.$blog_post-&gt;getTitle().&#039;</h3><p>&#039;;<br>echo nl2br($blog_post-&gt;getPost());<br>}<br>}<code>访问如下URL</code><a href="http://127.0.0.1/Magento/helloworld/blog/showAllBlogPosts%60">http://127.0.0.1/Magento/helloworld/blog/showAllBlogPosts`</a><br>你应该看到以下异常<br><code>include(Zhlmmc\Helloworld\Model\Resource\Mysql4\Blogpost\Collection.php)  [function.include]: failed to open stream: No such file or directory</code><br>我想你不会被这个异常吓到，已经熟门熟路了。我们需要添加一个PHP类，定义Blogpost的模型集合。每个模型都有一个“protected”属性 “_resourceCollectionName”【译者注：从父类“Mage_Core_Model_Abstract”继承来的】。这个属性的值是 这个模型对应的模型集合的URI。<br><code>protected &amp;#039;_resourceCollectionName&amp;#039; =&gt; string &amp;#039;helloworld/blogpost_collection&amp;#039;</code><br>在默认情况下，这个值是模型的URI加上“_collection”。Magento把模型集合也看做是一种资源（Resrouce），所以运用资源模型的命名规则，模型集合的全名是<br><code>Zhlmmc_Helloworld_Model_Resource_Mysql4_Blogpost_Collection</code><br>然后我们要创建如下文件<br><code>File: app/code/local/Zhlmmc/Helloworld/Model/Resource/Mysql4/Blogpost/Collection.php class Zhlmmc_Helloworld_Model_Resource_Mysql4_Blogpost_Collection extends Mage_Core_Model_Mysql4_Collection_Abstract &#123; protected function _construct() &#123; $this-&gt;_init(&amp;#039;helloworld/blogpost&amp;#039;); &#125; &#125;</code><br>这里的参数是模型的UR，用来I来初始化模型集合。刷新页面，你应该看到数据库中的Blog都显示出来了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>首先我要恭喜你，到这里你已经创建并配置了你的第一个Magento模型。在后面的章节中我们将讲解Magento的另外一种模型Entity Attribute Value Model。</p>
<p>在这章开始的时候，我撒了一个小谎。其实在Magento中，并不是所有的模型都继承自“Mage_Core_Model_Abstract”。在 Magento最初的版本中，这个抽象类并不存在。所以有很多模型是直接继承自“Varien_Object”。不过这些并不影响我们创建Magento 模型，了解一下就可以了，方便阅读Magento的代码。</p>

        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.foolbird.net/1754.html" data-id="cm4fsa2ca0011plv4gf0mce7o" class="article-share-link">Share</a>
      
        <a href="https://blog.foolbird.net/1754.html#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/11/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/13/">Next &raquo;</a>
    </nav>
  

</section>
        
          <aside id="sidebar">
  <div id="search-form-wrap">
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.foolbird.net"></form>
  </div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a><span class="category-list-count">43</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%98%E6%A1%A3/">存档</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%A3%E4%BC%A0/">宣传</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><span class="category-list-count">47</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%85%E8%A1%8C/">旅行</a><span class="category-list-count">29</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">December 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">April 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">March 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">January 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">November 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/10/">October 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">September 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/03/">March 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/01/">January 2012</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">December 2011</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/11/">November 2011</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/10/">October 2011</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/07/">July 2011</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/06/">June 2011</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/03/">March 2011</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/02/">February 2011</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/10/">October 2010</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/03/">March 2010</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/01/">January 2010</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/08/">August 2009</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/06/">June 2009</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2008/12/">December 2008</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2008/10/">October 2008</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2008/09/">September 2008</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2008/08/">August 2008</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2008/05/">May 2008</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2008/04/">April 2008</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/12/">December 2007</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/11/">November 2007</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/09/">September 2007</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/07/">July 2007</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/06/">June 2007</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/05/">May 2007</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/03/">March 2007</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/02/">February 2007</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/01/">January 2007</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2006/12/">December 2006</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2006 - 2024 王默 <a href="http://beian.miit.gov.cn/" target="_blank">吉ICP备13000316号-4</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/history" class="mobile-nav-link">History</a>
  
  
    <a class="mobile-nav-link" href="/atom.xml" title="RSS Feed">RSS</a>
  
</nav>
    
<script>
  var disqus_shortname = 'makerwang';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>



<script src="/js/jquery.min.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>